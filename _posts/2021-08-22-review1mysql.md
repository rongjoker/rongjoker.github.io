---
layout: post
title: 温故知新之Mysql
---

## Mysql如何实现事务

这是一个很大的问题。可以从事务的ACID特性的四个角度来分析。
D(durable 持久化)最简单。redo log
<br>
原子性：由undo保证； 持久性：由redo保证； 隔离性：由undo+事务ID+mvcc保证； 一致性：**由程序保障+AID，一致性是我们最终的目的。**

[![hpWHHA.md.png](https://z3.ax1x.com/2021/08/22/hpWHHA.md.png)](https://imgtu.com/i/hpWHHA)




### undo log && MVCC

**事务隔离是怎么通过read-view(读视图)实现的?**
每一行数有多个版本，当我们要去读取数据的时候，要判断这个数据的版本号，对当前事务而言，是否可见，如果不可见，则要根据undolog计算得到上一个版本。如果上一个版本也不符合要求，则要找到再上一个版本， 直到找到对应正确的数据版本。
<br>
**并发版本控制(MCVV)的概念是什么, 是怎么实现的?**
并不是数据版本比当前事务的ID大，对当前事务来说，此版本的数据不可见了。因为事务启动(begin)的时候就分配了事务ID，但是一致性视图是在第一个快照读的时候才创建的，如果在这段时间内(启动事务和一致性视图创建间隔)，有其他事务开启并提交了，对于当前事务来说这些提交依然是可见的，即使这些事务ID比当前事务的ID大
<br>
**使用长事务的弊病? 为什么使用常事务可能拖垮整个库?**
长事务导致表空间持续增长，即便是事务提交或者回滚后，回滚表空间被是否后，表空间大小仍然不会被缩小。
长事务的存在导致锁发生冲突或等待的几率大大增加。
如果某个应用有发生锁等待后尝试重新建立连接的机制，那么在发生锁等待或冲突的时候，应用就会不断地发起新的连接，导致MySQL的连接数被占用爆满。MySQL不能在提供连接服务，就挂掉了。

>http://bos.itdks.com/b2c20ce5c11940b6b0a4e98547f67664.pdf

> https://database.51cto.com/art/202101/641019.htm
> https://blog.csdn.net/SnailMann/article/details/94724197
> https://www.zhihu.com/question/370950509/answer/1958141987


