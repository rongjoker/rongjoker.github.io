---
layout: post
title: 温故知新之Mysql
---


### 第一讲 一条SQL如何执行

MySQL 可以分为 Server 层和存储引擎层两部分。Server 层包括连接器、查询缓存、分析器、优化器、执行器等，涵盖 MySQL 的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。而存储引擎层负责数据的存储和提取。<br>
1. 连接器(建立连接、获取权限、维护和管理连接)
2. 查询缓存(版本8取消了此功能)
3. 分析器(词法分析、语法分析、提示语法错误)
4. 优化器(通过分析器，明白你要干啥后，数据库就要针对你的需求想一个最优的解决方案，也就是执行计划，这个最优方案选择的操作，这个就是优化器要做的事情了。比如多个索引选择用哪个索引，多个表连接时选择什么连接顺序。优化器会改写sql，包括join的连接顺序，匹配索引，找到最优sql策略)
5. 执行器

   [![haeVkF.md.png](https://z3.ax1x.com/2021/08/31/haeVkF.md.png)](https://imgtu.com/i/haeVkF)

问题:如果表 T 中没有字段 k，而你执行了这个语句 select * from T where k=1, 那肯定是会报“不存在这个列”的错误： “Unknown column ‘k’ in ‘where clause’”。你觉得这个错误是在我们上面提到的哪个阶段报出来的呢？

答案: 《高性能mysql》里提到解析器和预处理器。 解析器处理语法和解析查询, 生成一课对应的解析树。 预处理器进一步检查解析树的合法。比如: 数据表和数据列是否存在, 别名是否有歧义等。如果通过则生成新的解析树，再提交给优化器。错误发生在在分析器处理阶段


### 第二讲 日志系统：一条SQL更新语句是如何执行的

WAL 的全称是 Write-Ahead Logging，它的关键点就是先写日志，再写磁盘。注意，日志也是写入硬盘，只不过顺序写入速度很快。也就是说，在实际写数据前，先把修改的数据记到日志文件中，以便故障时进行恢复。不过，Redis的AOF(Append Only File)日志正好相反，它是写后日志，“写后”的意思是 Redis 是先执行命令，把数据写入内存，然后才记录日志。 InnoDB正因为有了 redo log(重做日志)，才有了 crash-safe 的能力（即使mysql服务宕机，也不会丢失数据的能力）。
<br>
binlog只有在事务提交的时候才会写入,redolog在事务开启之后就会写入了,当数据库发生异常,事务还未提交的时候,这时候这个事务里的更新全部都会丢失,如果没有redolog写入更新的话,binlog里是不会有未提交的事务的数据的.
<br>binlog是追加写，crash时不能判定binlog中哪些内容是已经写入到磁盘，哪些还没被写入。而redolog是循环写，从check point到write pos间的内容都是未写入到磁盘的。

<br>
更新的过程
1. 执行器先找引擎取 ID=2 这一行。ID 是主键，引擎直接用树搜索找到这一行。如果 ID=2 这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。注意，是页，而不是一条数据。操作系统层面读取磁盘的最小单位就是页，内存页、cache页和磁盘页都是一样大小，一般是4B。
2. 执行器拿到引擎给的行数据，把这个值加上 1，比如原来是 N，现在就是 N+1，得到新的一行数据，再调用引擎接口写入这行新数据。
3. 引擎将这行新数据更新到内存中，同时将这个更新操作记录到 redo log 里面，此时 redo log 处于 prepare 状态。然后告知执行器执行完成了，随时可以提交事务。
4. 执行器生成这个操作的 binlog，并把 binlog 写入磁盘。
5. 执行器调用引擎的提交事务接口，引擎把刚刚写入的 redo log 改成提交（commit）状态，更新完成。
可见，更新是两阶段提交。

数据恢复。找到一个备份点。从备份的时间点开始，将备份的 binlog 依次取出来，重放到中午误删表之前的那个时刻。redo log 和 binlog 都可以用于表示事务的提交状态，而两阶段提交就是让这两个状态保持逻辑上的一致。在数据恢复和扩容时不会出现数据丢失或者主从数据库不一致。<br>
redolog是循环写的，不持久保存，binlog的“归档”这个功能，redolog是不具备的。


### 第三讲 事务隔离：为什么你改了我还看不见？

可重复读：事务在执行期间看到的数据前后必须是一致的。可重复读场景，其实就是事务开始以后不希望被打扰.事务启动时的视图可以认为是静态的，不受其他事务更新的影响。<br>
实际上每条记录在更新的时候都会同时记录一条回滚操作。记录上的最新值，通过回滚操作，都可以得到前一个状态的值。这一点被seata所借鉴。<br>
长事务的坏处:长事务意味着系统里面会存在很老的事务视图。由于这些事务随时可能访问数据库里面的任何数据，所以这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，这就会导致大量占用存储空间。<br>
避免长事务？ 长事务的来源应该是一次获取大量的数据，查询方式不合理（全表扫描）。 那么解决问题的方式是： 1）利用索引 2）分批获取数据.
创建视图快照会以select执行开始的时间点为快照点,而不是以begin为起始点

### 第四、五讲 深入浅出索引
主键索引的叶子节点存的是整行数据。在 InnoDB 里，主键索引也被称为聚簇索引（clustered index）。非主键索引的叶子节点内容是主键的值。在 InnoDB 里，非主键索引也被称为二级索引（secondary index）。即普通索引查询方式，则需要先搜索 k 索引树，得到 ID 的值为 500，再到 ID 索引树搜索一次。这个过程称为回表。<br>
b+树的容量:以 InnoDB 的一个整数字段索引为例，这个 N 差不多是 1200。这棵树高是 4 的时候，就可以存 1200 的 3 次方个值，这已经 17 亿了。考虑到树根的数据块总是在内存中的，一个 10 亿行的表上一个整数字段的索引，查找一个值最多只需要访问 3 次磁盘。其实，树的第二层也有很大概率在内存中，那么访问磁盘的平均次数就更少了。<br>
回表：<br>
逐个找到符合条件的叶子节点，再根据其存储的主键值逐一回表查询。并不是直接一次性查出符合条件的主键值，然后一次性回表查询。回表次数比想象得要多得多。
<br>
MySQL 5.6 引入的索引下推优化（index condition pushdown)， 可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。
```

CREATE TABLE `geek` (
  `a` int(11) NOT NULL,
  `b` int(11) NOT NULL,
  `c` int(11) NOT NULL,
  `d` int(11) NOT NULL,
  PRIMARY KEY (`a`,`b`),
  KEY `c` (`c`),
  KEY `ca` (`c`,`a`),
  KEY `cb` (`c`,`b`)
) ENGINE=InnoDB;

```
对于二级索引C，会默认和主键做联合索引。所以索引c的排序为cab，索引cb的排序顺序为cba。所以，结论是 ca 可以去掉，cb 需要保留。
<br>
为什么要重建索引。我们文章里面有提到，索引可能因为删除，或者页分裂等原因，导致数据页有空洞，重建索引的过程会创建一个新的索引，把数据按顺序插入，这样页面的利用率最高，也就是索引更紧凑、更省空间。


### 第六讲 全局锁和表锁 ：给表加个字段怎么有这么多阻碍？







## Mysql如何实现事务

这是一个很大的问题。可以从事务的ACID特性的四个角度来分析。



[![hpWHHA.md.png](https://z3.ax1x.com/2021/08/22/hpWHHA.md.png)](https://imgtu.com/i/hpWHHA)




### undo log && MVCC

